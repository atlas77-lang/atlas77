import "std/vector";
import "std/optional";
import "std/string";
import "std/mem";

//TODO: Add Iter<T>::from_map(Map<K, V>)
public struct Iter<T> {
public:
    data: Vector<T>;
    index: uint64;

    Iter(data: Vector<T>) {
        this.data = data;
        this.index = 0u;
    }
    ~Iter() {
        delete this.data;
    }
    Iter(from: &const Iter<T>)
        where T: std::copyable
    {
        this.data = *from.data;
        this.index = *from.index;
    }
    /// Returns the next item in the iterator, or None if the end is reached.
    /// Note: For non-copyable types, this will copy the element.
    fun next(&this) -> optional<T> {
        if this.index >= this.data.length {
            return optional<T>::empty();
        }
        
        // We use take to move the first item (the next one) out of the vector
        // This avoids copying for non-copyable types
        let item: T = this.data.take(0u);
        return optional<T>::of(item);
    }
    /// Peeks at the next item without advancing the iterator
    fun peek(&this) -> optional<&const T> {
        if this.index >= this.data.length {
            return optional<&const T>::empty();
        }
        // 1 
        let item = this.data.get(1u);
        return optional<&const T>::of(item);
    }

    fun from_array(data: [T]) -> Iter<T> {
        let vector = new Vector<T>(data);
        return new Iter<T>(vector);
    }

    fun has_next(&this) -> bool {
        return this.index < this.data.length;
    }
    
    fun from_string(data: String) -> Iter<char> {
        let chars: [char] = to_chars(&data.s);
        let vector = new Vector<char>(chars);
        return new Iter<char>(vector);
    }

    fun from_str(data: &const string) -> Iter<char> {
        let chars: [char] = to_chars(data);
        let vector = new Vector<char>(chars);
        return new Iter<char>(vector);
    }
}
