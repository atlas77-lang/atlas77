//package std::result;

import "std/io";

/// Does nothing apart from tricking the type system
private extern result_default<T>() -> T;

private enum ResultTag {
    OK = 0;
    ERR = 256;
}

public struct Result<T, E> {
private:
    data: T;
    err: E;
    tag: ResultTag;

    Result(data: T, err: E, tag: ResultTag) {
        this.data = data;
        this.err = err;
        this.tag = tag;
    }
    ~Result() {}
public:
    fun ok(data: T) -> Result<T, E> {
        return new Result<T, E>(data, result_default::<E>(), ResultTag::OK);
    }

    fun err(err: E) -> Result<T, E> {
        return new Result<T, E>(result_default::<T>(), err, ResultTag::ERR);
    }

    fun is_ok(this) -> bool {
        return this.tag == ResultTag::OK;
    }

    fun is_err(this) -> bool {
        return this.tag == ResultTag::ERR;
    }

    fun unwrap(this) -> T {
        if this.is_err() {
            panic("Unwrap called on an Err");
        }
        return this.data;
    }

    fun unwrap_err(this) -> E {
        if this.is_ok() {
            panic("Unwrap_err called on an Ok");
        }
        return this.err;
    }

    fun unwrap_or(this, default: T) -> T {
        if this.is_ok() {
            return this.data;
        }
        return default;
    }

    fun unwrap_err_or(this, default: E) -> E {
        if this.is_err() {
            return this.err;
        }
        return default;
    }
}
