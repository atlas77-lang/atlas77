/* 
 * Experimental implementation of the Vector types in Atlas77.
 *
 * This tries to leverage the C backend properly and not rely 
 * on the VM external function like in std/vector.atlas 
 * (which is discard due to the removal of the VM itself).
 *
 * Very early implementation, it aims to reimplement the entire 
 * std::vector functionality in Atlas77 eventually, and replace the old one.
 */

extern fun malloc<T>(size: uint64) -> ptr<T>;
// realloc helper
extern fun realloc<T>(pointer: ptr<T>, new_size: uint64) -> ptr<T>;
extern fun free<T>(pointer: ptr<T>);

public struct CVec<T> {
//! Equivalent to T* in C.
    data: ptr<T>;
public:
    len: uint64;
    capacity: uint64;
    // It takes in a [T], because the [T] types is safe in Atlas77. ptr<T> isn't as it's a entirely a raw pointer
    CVec(data: [T], len: uint64, capacity: uint64) {
        // This is 100% a lie, but trust
        this.data = data as ptr<T>;
        this.len = len;
        this.capacity = capacity;
    }
    ~CVec() {
        free<T>(this.data);
    }
    fun with_capacity(capacity: uint64) -> CVec<T> {
        // Allocate memory using calloc
        let data = malloc<T>(capacity*8u) as [T];
        return new CVec<T>(data, 0u, capacity);
    }
    fun get(&const this, index: uint64) -> &const T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun get_mut(&this, index: uint64) -> &T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun push(&this, value: T) {
        if (*this).len >= (*this).capacity {
            // Reallocate with double capacity
            let new_capacity: uint64 = 0u;
            if (*this).capacity == 0u {
                new_capacity = 1u;
            } else {
                new_capacity = (*this).capacity * 2u;
            }
            let new_data = realloc<T>((*this).data, new_capacity * 8u);
            (*this).data = new_data;
            (*this).capacity = new_capacity;
        }
        (*this).data[(*this).len] = value;
        (*this).len = (*this).len + 1u;
    }
    fun len(&const this) -> uint64 {
        return (*this).len;
    }
    fun pop(&this) -> T {
        if (*this).len == 0u {
            panic("Pop from empty CVec");
        }
        (*this).len = (*this).len - 1u;
        return (*this).data[(*this).len];
    }
}
