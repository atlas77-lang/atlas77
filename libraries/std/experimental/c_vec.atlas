/* 
 * Experimental implementation of the Vector types in Atlas77.
 *
 * This tries to leverage the C backend properly and not rely 
 * on the VM external function like in std/vector.atlas 
 * (which is discard due to the removal of the VM itself).
 *
 * Very early implementation, it aims to reimplement the entire 
 * std::vector functionality in Atlas77 eventually, and replace the old one.
 */

union Optional<T> {
    Some: T;
    None: ptr<unit>;
}

extern malloc<T>(size: uint64) -> ptr<T>;
// realloc helper
extern realloc<T>(pointer: ptr<T>, new_size: uint64) -> ptr<T>;
extern free<T>(pointer: ptr<T>);


public struct CVec<T> {
//! Equivalent to T* in C.
    data: ptr<T>;
public:
    len: uint64;
    capacity: uint64;
    // It takes in a [T], because the [T] types is safe in Atlas77. ptr<T> isn't as it's a entirely a raw pointer
    CVec(data: [T], len: uint64, capacity: uint64) {
        // This is 100% a lie, but trust
        this.data = data as ptr<T>;
        this.len = len;
        this.capacity = capacity;
    }
    ~CVec() {
        free<T>(this.data);
    }
    fun with_capacity(capacity: uint64) -> CVec<T> {
        // Allocate memory using calloc
        let data = malloc<T>(capacity*8u) as [T];
        return new CVec<T>(data, 0u, capacity);
    }
    fun get(&const this, index: uint64) -> &const T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun get_mut(&this, index: uint64) -> &T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun push(&this, value: T) {
        if (*this).len >= (*this).capacity {
            // Reallocate with double capacity
            let new_capacity = 0u;
            if (*this).capacity == 0u {
                new_capacity = 1u;
            } else {
                new_capacity = (*this).capacity * 2u;
            }
            let new_data = realloc<T>((*this).data, new_capacity * 8u);
            (*this).data = new_data;
            (*this).capacity = new_capacity;
        }
        (*this).data[(*this).len] = value;
        (*this).len = (*this).len + 1u;
    }
    fun len(&const this) -> uint64 {
        return (*this).len;
    }
    fun pop(&this) -> T {
        if (*this).len == 0u {
            panic("Pop from empty CVec");
        }
        (*this).len = (*this).len - 1u;
        return (*this).data[(*this).len];
    }
}

extern printf<T>(format: string, arg: T);

fun main() {
    let vec = CVec<int64>::with_capacity(10u);
    printf("CVec created with capacity: %llu\n", vec.len);
    vec.push(0);
    vec.push(1);
    vec.push(2);
    vec.push(3);
    let mut_ref = vec.get_mut(0u);
    *mut_ref = 42;
    let const_ref = vec.get(0u);
    assert(*const_ref == 42);
    while (vec.len < vec.capacity) {
        vec.push(vec.len as int64);
    }
    assert(vec.len == vec.capacity);
    vec.push(100);
    assert(vec.len != vec.capacity);
    let i = 0u;
    while (i < vec.len) {
        let val = vec.get(i);
        printf("vec[%llu]", i);
        printf("= %lld, ", *val);
        i = i + 1u;
    }
    printf("Length after pushes: %llu\n", vec.len);
    printf("Capacity after pushes: %llu\n", vec.capacity);

    let option = Optional<int64> {
        .Some = 42,
    };
    
}

extern panic(msg: string);

fun assert(cond: bool) {
    if !cond {
        panic("Assertion failed");
    }
}