/* 
 * Experimental implementation of the Vector types in Atlas77.
 *
 * This tries to leverage the C backend properly and not rely 
 * on the VM external function like in std/vector.atlas 
 * (which is discard due to the removal of the VM itself).
 *
 * Very early implementation, it aims to reimplement the entire 
 * std::vector functionality in Atlas77 eventually, and replace the old one.
 */

extern fun malloc<T>(size: uint64) -> ptr<T>;
// realloc helper
extern fun realloc<T>(pointer: ptr<T>, new_size: uint64) -> ptr<T>;
extern fun free<T>(pointer: ptr<T>);

public struct CVec<T> {
    //! Equivalent to T* in C.
    data: ptr<T>;
public:
    len: uint64;
    capacity: uint64;
private:
    //! Private constructor (only used internally)
    Cvec(data: [T], len: uint64, capacity: uint64) {
        // Allocate memory using malloc
        let data_ptr = malloc<T>(capacity * size_of<T>());
        // Copy data into allocated memory
        let i = 0u;
        while i < len {
            data_ptr[i] = data[i];
            i = i + 1u;
        }
        this.data = data_ptr;
        this.len = len;
        this.capacity = capacity;
    }
public:
    //! Default constructor
    CVec() {
        // This is 100% a lie, but trust
        // Minimum size is 16 elements
        this.data = malloc<T>(size_of<T>() * 16u);
        this.len = 0u;
        this.capacity = 16u;
    }
    ~CVec() {
        free<T>(this.data);
    }
    //! Create a CVec from a slice by copying the data
    fun from(slice: [T]) -> CVec<T> 
    where T: std::copyable
    {

    }
    //! Create a CVec from a slice by moving the data
    fun move_into(slice: [T]) -> CVec<T>
    where T: std::moveable
    {

    }
    fun with_capacity(capacity: uint64) -> CVec<T> {
        // Allocate memory using calloc
        let data = malloc<T>(capacity*8u) as [T];
        return new CVec<T>(data, 0u, capacity);
    }
    fun get(&const this, index: uint64) -> &const T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun get_mut(&this, index: uint64) -> &T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun push(&this, value: T) {
        if (*this).len >= (*this).capacity {
            // Reallocate with double capacity
            let new_capacity: uint64 = 0u;
            if (*this).capacity == 0u {
                new_capacity = 1u;
            } else {
                new_capacity = (*this).capacity * 2u;
            }
            let new_data = realloc<T>((*this).data, new_capacity * 8u);
            (*this).data = new_data;
            (*this).capacity = new_capacity;
        }
        (*this).data[(*this).len] = value;
        (*this).len = (*this).len + 1u;
    }
    fun len(&const this) -> uint64 {
        return (*this).len;
    }
    fun pop(&this) -> T {
        if (*this).len == 0u {
            panic("Pop from empty CVec");
        }
        (*this).len = (*this).len - 1u;
        return (*this).data[(*this).len];
    }
}
