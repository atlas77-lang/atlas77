/* 
 * Experimental implementation of the Vector types in Atlas77.
 *
 * This tries to leverage the C backend properly and not rely 
 * on the VM external function like in std/vector.atlas 
 * (which is discard due to the removal of the VM itself).
 *
 * Very early implementation, it aims to reimplement the entire 
 * std::vector functionality in Atlas77 eventually, and replace the old one.
 */

extern malloc<T>(size: uint64) -> ptr<T>;

public struct CVec<T> {
//! Equivalent to T* in C.
    data: ptr<T>;
public:
    len: uint64;
    capacity: uint64;
    // It takes in a [T], because the [T] types is safe in Atlas77. ptr<T> isn't as it's a entirely a raw pointer
    CVec(data: [T], len: uint64, capacity: uint64) {
        // This is 100% a lie, but trust
        this.data = data as ptr<T>;
        this.len = len;
        this.capacity = capacity;
    }
    fun with_capacity(capacity: uint64) -> CVec<T> {
        // Allocate memory using calloc
        let data = malloc<T>(capacity*8u) as [T];
        return new CVec<T>(data, 0u, capacity);
    }
    fun get(&const this, index: uint64) -> &const T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun get_mut(&this, index: uint64) -> &T {
        if index >= (*this).len {
            panic("Index out of bounds");
        }
        return &((*this).data[index]);
    }
    fun push(&this, value: T) {
        if (*this).len >= (*this).capacity {
            panic("CVec capacity exceeded");
        }
        (*this).data[(*this).len] = value;
        (*this).len = (*this).len + 1u;
    }
}

extern printf<T>(format: string, arg: T);

fun main() {
    let vec = CVec<int64>::with_capacity(10u);
    printf("CVec created with capacity: %llu\n", vec.len);
    vec.push(0);
    vec.push(1);
    vec.push(2);
    vec.push(3);
    let mut_ref = vec.get_mut(0u);
    *mut_ref = 42;
    let const_ref = vec.get(0u);
    assert(*const_ref == 42);
    while (vec.len < vec.capacity) {
        vec.push(vec.len as int64);
    }
    assert(vec.len == vec.capacity);
    let i = 0u;
    while (i < vec.len) {
        let val = vec.get(i);
        printf("vec[%llu]", i);
        printf("= %lld\n", *val);
        i = i + 1u;
    }
}

extern panic(msg: string);

fun assert(cond: bool) {
    if !cond {
        panic("Assertion failed");
    }
}