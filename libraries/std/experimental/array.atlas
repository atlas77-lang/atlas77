package std::array;

import "std/experimental/slice";

//! Allocation on the stack
extern fun alloca<T>(size: uint64) -> ptr<T>;
//! Allocation on the heap
extern fun malloc<T>(size: uint64) -> ptr<T>;
/*
 * Similar to the std::vector, but with a fixed size known at compile time.
 * If the size is small enough, the data is stored inline, else it is allocated on the heap.
 * This is obviously experimental and DOES NOT work yet. (const_expr doesn't exist yet)
 */
// Above this threshold, we allocate the array on the heap
const INLINE_THRESHOLD: uint64 = 256u;
//! Owned fixed-size array, copyable & moveable if T is copyable & moveable
//! Cannot be returned from functions as its data lives on the stack
#[no_return]
public struct Array<T, N> {
    data: Slice<T, _ConstMeta<N>>;
public:
    // Normal constructor
    Array(data: [T; N]) {
        this.data = data;
    }
    // Default constructor
    Array() {
        this.data = const_expr(
            if N > INLINE_THRESHOLD then 
                 new Slice<T, _ConstMeta<N>>(malloc<T>(N * sizeof<T>()), new _ConstMeta<N>()) 
            else new Slice<T, _ConstMeta<N>>(alloca<T>(N * sizeof<T>()), new _ConstMeta<N>())
        );
    }
    // Copy constructor
    Array(from: &const Array<T, N>)
        where T: std::copyable
    {
        this.data = this.data = const_expr(
            if N > INLINE_THRESHOLD then 
                 new Slice<T, _ConstMeta<N>>(malloc<T>(N * sizeof<T>()), new _ConstMeta<N>()) 
            else new Slice<T, _ConstMeta<N>>(alloca<T>(N * sizeof<T>()), new _ConstMeta<N>())
        );
        let i = 0u;
        while i < N {
            (*this).data[i] = (*from).data[i];
            i = i + 1u;
        }
    }
    // Move constructor
    Array(from: &Array<T, N>)
        where T: std::moveable
    {
        this.data = const_expr(
            if N > INLINE_THRESHOLD then 
                 new Slice<T, _ConstMeta<N>>(malloc<T>(N * sizeof<T>()), new _ConstMeta<N>()) 
            else new Slice<T, _ConstMeta<N>>(alloca<T>(N * sizeof<T>()), new _ConstMeta<N>())
        );
        let i = 0u;
        while i < N {
            (*this).data[i] = move<T>(&(*from).data[i]);
            i = i + 1u;
        }
    }
    ~Array() {
        // Only free if allocated on the heap
        const_expr(
            if N > INLINE_THRESHOLD then 
                 free<T>((*this).data.data) 
        );
    }
    operator [](&const this, index: uint64) -> &const T {
        return (*this).data.get(index);
    }
    operator []=(&this, index: uint64, value: T) -> &T {
        let slot = (*this).data.get_mut(index);
        *slot = value;
        return slot;
    }
    #[inline]
    fun get(&const this, index: uint64) -> &const T {
        if index >= N {
            panic("Index out of bounds");
        }
        return (*this).data.get(index);
    }
    #[inline]
    fun get_mut(&this, index: uint64) -> &T {
        if index >= N {
            panic("Index out of bounds");
        }
        return (*this).data.get_mut(index);
    }
    #[inline]
    fun set(&this, index: uint64, value: T) {
        if index >= N {
            panic("Index out of bounds");
        }
        (*this).data.set(index, value);
    }
    #[inline]
    const fun len(&const this) -> uint64 {
        return N;
    }
}