//! An `optional<T>` type for representing values that may be absent.
//! Safe wrapper to avoid null pointers and uninitialized values.
public struct Optional<T> {
private:
    val: ptr<T>;
    has_value: bool;
    Optional(val: ptr<T>, has_value: bool) {
        this.val = val;
        this.has_value = has_value;
    }
public:
    //! Default constructor: creates an empty `optional<T>`.
    Optional() {
        this.val = null;
        this.has_value = false;
    }
    Optional(from: const Optional<T>&)
        where T: std::copyable
    {
        this.has_value = from.has_value;
        if (this.has_value) {
            this.val = from.val;
        } else {
            this.val = null;
            this.has_value = false;
        }
    }
    Optional(dying_obj: Optional<T>&&)
    {
        this.has_value = dying_obj.has_value;
        this.val = dying_obj.val;
        dying_obj.has_value = false;
        dying_obj.val = null;
    }
    //! Destructor: deletes the contained value if present.
    ~Optional() {
        if (this.has_value) {
            /*
            Note to myself:
            `delete` on `ptr<T>` will generate this code in C:
                if (ptr != NULL) {
                    t_destructor(ptr);
                    free(ptr);
                }
             */
            delete this.val;
        }
    }
    //! Construct an `optional<T>` containing `value`.
    //! Example:
    //!     let opt = optional<int64>::of(42);
    //!
    //! NB: Takes ownership of `value`
    fun of(value: T) -> Optional<T> {
        let val_ptr = malloc<T>(size_of<T>());
        *val_ptr = value;
        return new Optional<T>(val_ptr, true);
    }
    //! Check if the optional contains a value.
    fun has_value(const this&) -> bool {
        return this.has_value;
    }
}