// An experimental implementation of an optional type in Atlas
// As of the v0.6.x series, it doesn't work and is only for demonstration purposes.
// The union type isn't supported properly yet.
// I am still gathering my thoughts on the design both in syntax and semantics about unions.

import "std/io";

// We need a way to enforce T to be copyable later on
// But it shouldn't be a trait/interface because copyability is not a behavior
// It's a property of the type itself
// Could there be a way to express this in the type system?
private union optional_storage<T: std::copyable> { 
    value: T;
    empty: unit;
}

public struct optional<T: std::copyable> {
private:
    data: optional_storage<T>;
    is_some: bool;
    // Private constructor
    optional(data: optional_storage<T>, is_some: bool) {
        this.data = data;
        this.is_some = is_some;
    }
public:
    // Destructor to clean up the stored value if it exists
    ~optional() {
        if (this.is_some) {
            delete this.data.value;
        }
    }
    // First draft of a copy constructor
    fun _copy(&const this) -> optional<T> {
        if (this.is_some) {
            return optional::<T>::some(this.data.value);
        } else {
            return optional::<T>::none();
        }
    }
    fun some(data: T) -> optional<T> {
        return new optional<T>(
            optional_storage<T> { 
                .value = data 
            }, 
            true
        );
    }
    fun none() -> optional<T> {
        return new optional<T>(
            optional_storage<T> { 
                .empty = unit 
            }, 
            false
        );
    }
    fun is_some(this) -> bool {
        return this.is_some;
    }
    fun is_none(this) -> bool {
        return !this.is_some;
    }
    fun unwrap(this) -> T {
        if (!this.is_some) {
            panic("Called unwrap on a none value");
        } else {
            return this.data.value;
        }
    }
    fun unwrap_or(this, default: T) -> T {
        if (this.is_some) {
            return this.data.value;
        } else {
            return default;
        }
    }
    fun map<U>(this, f: (T) -> U) -> optional<U> {
        if (this.is_some) {
            return optional<U>::some(f(this.data.value));
        } else {
            return optional<U>::none();
        }
    }
}