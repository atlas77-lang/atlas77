// An experimental implementation of an optional type in Atlas
// As of the v0.6.x series, it doesn't work and is only for demonstration purposes.
// The union type isn't supported properly yet.
// I am still gathering my thoughts on the design both in syntax and semantics about unions.

import "std/io";

// We need a way to enforce T to be copyable later on
// But it shouldn't be a trait/interface because copyability is not a behavior
private union optional_storage<T: std::copyable> { 
    value: T;
    empty: unit;
}

public struct optional<T: std::copyable> {
private:
    data: optional_storage<T>;
    has_value: bool;
    // Private constructor
    optional(data: optional_storage<T>, has_value: bool) {
        this.data = data;
        this.has_value = has_value;
    }
public:
    // Destructor to clean up the stored value if it exists
    ~optional() {
        if (this.has_value) {
            delete this.data.value;
        }
    }
    // First draft of a copy constructor
    fun _copy(&const this) -> optional<T> {
        if (this.has_value) {
            return optional<T>::some(this.data.value);
        } else {
            return optional<T>::empty();
        }
    }
    // Needs a better name than `some`
    fun some(data: T) -> optional<T> {
        return new optional<T>(
            optional_storage<T> { 
                .value = data 
            }, 
            true
        );
    }
    fun empty() -> optional<T> {
        return new optional<T>(
            optional_storage<T> { 
                .empty = () 
            }, 
            false
        );
    }
    fun has_value(this) -> bool {
        return this.has_value;
    }
    // Unwrap the value, panicking if it's empty
    // TODO: Add T! to indicate possible panic
    fun value(this) -> T {
        if (!this.has_value) {
            panic("Called value on a empty optional");
        } else {
            return this.data.value;
        }
    }
    fun value_or(this, default: T) -> T {
        if (this.has_value) {
            return this.data.value;
        } else {
            return default;
        }
    }
    // Function pointers are not supported yet, so this is just a placeholder
    fun map<U>(this, f: (T) -> U) -> optional<U> {
        if (this.has_value) {
            return optional<U>::some(f(this.data.value));
        } else {
            return optional<U>::empty();
        }
    }
}

// Example usage will be removed once this API is stable
fun test() {
    let opt1: optional<int64> = optional<int64>::some(10);
    if (opt1.has_value()) {
        let value = opt1.value();
        print("Got value: ");
        println(value);
    } else {
        println("No value present.");
    }

    let opt2: optional<string> = optional<string>::empty();
    let value_or_default = opt2.value_or("default");
    print("Value or default: ");
    print(value_or_default);
}
