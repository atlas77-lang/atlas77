// An experimental implementation of an optional type in Atlas
// As of v0.6.3, it is supported & the v0.6.4 supports generic constraints.
//! Optional type utilities for values that may or may not be present.
//!
//! This module provides a minimal `optional<T>` with creation helpers,
//! presence checks, safe accessors, and a destructor that cleans up
//! the stored value when present.


//! Internal storage for `optional<T>`.
//!
//! This untagged union holds either a `value: T` when present or
//! a zero-sized `empty: unit` sentinel when absent. Presence is
//! tracked by `optional<T>::has_value`.
private union optional_storage<T> { 
    value: T;
    // Temporary placeholder for empty state
    empty: int64;
}

//! A lightweight container for an optional value of type `T`.
//!
//! - When `has_value` is true, `data.value` is valid and will be dropped
//!   by the destructor.
//! - Create instances via `optional::of(value)` or `optional::empty()`.
public struct optional<T> {
private:
    data: optional_storage<T>;
    has_value: bool;
    //! Private constructor used by helpers `of` and `empty`.
    optional(data: optional_storage<T>, has_value: bool) {
        this.data = data;
        this.has_value = has_value;
    }
public:
    //! Destructor: drops the contained value if present.
    //!
    //! If `has_value` is true, `this.data.value` is deleted. Otherwise,
    //! nothing is performed.
    ~optional() {
        if (this.has_value) {
            delete this.data.value;
        }
    }
    optional(from: &const optional<T>)
        where T: std::copyable
    {
        this.has_value = *from.has_value;
        if (this.has_value) {
            this.data.value = *from.data.value;
        } else {
            this.data = optional_storage<T> {
                .empty = 0,
            };
            this.has_value = false;
        }
    }

    //! Construct an `optional<T>` containing `data`.
    //!
    //! Example:
    //!     let some = optional<int64>::of(42);
    fun of(data: T) -> optional<T> {
        return new optional<T>(
            optional_storage<T> { 
                .value = data 
            }, 
            true
        );
    }
    //! Construct an empty `optional<T>` with no value.
    //!
    //! Example:
    //!     let none = optional<int64>::empty();
    fun empty() -> optional<T> {
        return new optional<T>(
            optional_storage<T> { 
                .empty = 0
            }, 
            false
        );
    }
    fun is_empty(&const this) -> bool {
        return !(*this).has_value;
    }
    //! Returns true if a value is present.
    //!
    //! Example:
    //!     if (opt.has_value()) { println("has value"); }
    fun has_value(&const this) -> bool {
        return (*this).has_value;
    }
    //! Consume the optional and return the contained value.
    //!
    //! Panics with a descriptive message when `has_value` is false.
    //! Consider using `value_or(default)` to avoid panics.
    fun value(this) -> T {
        if (!this.has_value) {
            panic("Called value on a empty optional");
        }
        let value = this.data.value;
        // Mark as empty before returning to prevent destructor from double-freeing
        this.has_value = false;
        // Delete the container structure itself (but not the value we already moved)
        delete this;
        return value;
    }
    //! Consume the optional and return the contained value or `default` if empty.
    //!
    //! Example:
    //!     let opt = optional<int64>::empty();
    //!     let n = opt.value_or(0);
    fun value_or(this, default: T) -> T {
        if (this.has_value) {
            let value = this.data.value;
            // Mark as empty before returning
            this.has_value = false;
            // Delete the container structure itself
            delete this;
            return value;
        } else {
            delete this;
            return default;
        }
    }
    //! Because of an issue with nested references in generic
    //! This method is currently disabled.
    //! Tracked by https://github.com/atlas77-lang/atlas77/issues/153
    // fun as_ref(&const this) -> optional<&const T> {
    //     if (this.has_value) {
    //         return optional<&const T>::of(&this.data.value);
    //     } else {
    //         return optional<&const T>::empty();
    //     }
    // }
    // Function pointers are not supported yet, so this is just a placeholder
    //fun map<U>(this, f: (T) -> U) -> optional<U> {
    //    if (this.has_value) {
    //        return optional<U>::of(f(this.data.value));
    //    } else {
    //        return optional<U>::empty();
    //    }
    //}
}
