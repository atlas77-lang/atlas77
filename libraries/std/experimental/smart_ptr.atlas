import "std/io";

extern fun forget<T>(val: T);
extern fun malloc<T>() -> ptr<T>;

//! Internal reference-count block used by `rc_ptr`.
#[std::non_copyable]
private struct RcBlock<T> {
public:
    //! Strong reference count.
    strong: uint64;
    //! Owned value.
    value: T;
    //! Construct a block with initial strong count and a value.
    RcBlock(strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
    //! Drop the owned value when the block is freed.
    ~RcBlock() {
        delete this.value;
    }
    //! Set block fields.
    fun set(&this, strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
}

//! Experimental ref-counted pointer.
public struct rc_ptr<T> {
private:
    //! Pointer to the shared block.
    block: ptr<RcBlock<T>>;
    //! Private constructor used to create an `rc_ptr` from an existing block.
    rc_ptr(block: ptr<RcBlock<T>>) {
        this.block = block;
    }
public:
    //! Custom destructor - release the reference.
    ~rc_ptr() {
        this.release();
    }
    //! Copy (increments refcount).
    rc_ptr(from: &const rc_ptr<T>) {
        let strong = *from.block.strong;
        this.block = *from.block;
        (*this.block.strong) = strong + 1u;
    }
    //! Move
    rc_ptr(dying_obj: &move rc_ptr<T>) {
        this.block = dying_obj.block;
        // Invalidate the moved-from object to prevent double release.
        dying_obj.block = null;
    }
    //! Allocate a new `rc_ptr` owning `val`.
    fun make(val: T) -> rc_ptr<T> {
        let block: ptr<RcBlock<T>> = malloc<RcBlock<T>>();
        (*block).set(1u, val);
        return new rc_ptr<T>(block);
    }

    //! Release ownership; free block when count hits zero.
    fun release(this) {
        if this.block == null {
            return; // No block to release (moved-from state).
        }
        let old = *this.block.strong;
        if old == 0u {
            panic("double release");
        }
        let new_counter = old - 1u;
        (*this.block.strong) = new_counter;

        if new_counter == 0u {
            delete this.block;
        }
    }

    //! Return a const reference to the value.
    fun get(&this) -> &const T {
        if this.block == null {
            panic("dereferencing moved-from rc_ptr");
        } else if *this.block.strong == 0u {
            panic("dereferencing released rc_ptr");
        }
        return this.block.value;
    }

    //! Return a mutable reference to the value.
    fun get_mut(&this) -> &T {
        if this.block == null {
            panic("dereferencing moved-from rc_ptr");
        } else if *this.block.strong == 0u {
            panic("dereferencing released rc_ptr");
        }
        return this.block.value;
    }

    fun take(this) -> T {
        if this.block == null {
            panic("taking from moved-from rc_ptr");
        } else if *this.block.strong == 0u {
            panic("taking from released rc_ptr");
        }
        let val = this.block.value;
        this.block.strong = 0u; // Mark as released to prevent double release.
        // Invalidate the block to prevent double release.
        this.block = null;
        return val;
    }
}

extern fun len<T>(data: &[T]) -> uint64;

struct vector<T> {
public:
    // Just for testing
    data: [T; 5];
    length: uint64;
public:
    vector(data: [T; 5]) {
        this.length = len(&data);
        this.data = data;
    }
}

fun main() {
    let vec = new vector<int64>([1, 2, 3, 4, 5]);
    let rc_vec = rc_ptr::<vector<int64>>::make(vec);
    // This should trigger the copy constructor
    let rc_vec_clone = rc_vec;
    print("Length of rc_vec: ");
    printf("%d\n", rc_vec.get().length);
    print("Length of rc_vec_clone: ");
    printf("%d\n", rc_vec_clone.get().length);
}