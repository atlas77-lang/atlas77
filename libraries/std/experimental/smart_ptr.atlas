import "std/io";

extern forget<T>(val: T);
extern mem_alloc<T>() -> &T;

// The block itself cannot be copied
#[std::non_copyable]
private struct RcBlock<T> {
public:
    strong: uint64;
    value: T;
    RcBlock(strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
    ~RcBlock() {
        delete this.value;
    }
    fun set(&this, strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
}

// Ref-counted pointer implementation
public struct rc_ptr<T> {
private:
    block: &RcBlock<T>;
    /// Private constructor
    /// Used internally to create a rc_ptr from an existing RcBlock
    rc_ptr(block: &RcBlock<T>) {
        this.block = block;
    }
public:
    // custom destructor
    ~rc_ptr() {
        this.release();
    }
    rc_ptr(from: &const rc_ptr<T>) {
        let strong = *from.block.strong;
        this.block = *from.block;
        *this.block.strong = strong + 1u;
    }
    fun new_rc_ptr(val: T) -> rc_ptr<T> {
        let block: &RcBlock<T> = mem_alloc<RcBlock<T>>();
        block.set(1u, val);
        return new rc_ptr<T>(block);
    }

    fun release(this) {
        let old = *this.block.strong;
        if old == 0u {
            panic("double release");
        }
        let new_counter = old - 1u;
        *this.block.strong = new_counter;

        if new_counter == 0u {
            delete this.block; //Shouldn't we also free the ``rc_ptr`` itself?
        }
    }

    fun get(&this) -> &const T {
        return this.block.value;
    }

    fun get_mut(&this) -> &T {
        return this.block.value;
    }
}

extern len<T>(data: &[T]) -> uint64;

struct vector<T> {
public:
    data: [T];
    length: uint64;
public:
    vector(data: [T]) {
        this.length = len(&data);
        this.data = data;
    }
}

fun main() {
    let vec = new vector<int64>(new [int64; 3]);
    let rc_vec = rc_ptr::<vector<int64>>::new_rc_ptr(vec);
    // This should trigger the copy constructor
    let rc_vec_clone = rc_vec;
    println("Length of rc_vec: ");
    println(rc_vec.get().length);
    println("Length of rc_vec_clone: ");
    println(rc_vec_clone.get().length);
}