import "std/io";

extern forget<T>(val: T);
extern mem_alloc<T>() -> &T;

//! Internal reference-count block used by `rc_ptr`.
#[std::non_copyable]
private struct RcBlock<T> {
public:
    //! Strong reference count.
    strong: uint64;
    //! Owned value.
    value: T;
    //! Construct a block with initial strong count and a value.
    RcBlock(strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
    //! Drop the owned value when the block is freed.
    ~RcBlock() {
        delete this.value;
    }
    //! Set block fields.
    fun set(&this, strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
}

//! Experimental ref-counted pointer.
public struct rc_ptr<T> {
private:
    //! Pointer to the shared block.
    block: &RcBlock<T>;
    //! Private constructor used to create an `rc_ptr` from an existing block.
    rc_ptr(block: &RcBlock<T>) {
        this.block = block;
    }
public:
    //! Custom destructor - release the reference.
    ~rc_ptr() {
        this.release();
    }
    //! Copy (increments refcount).
    rc_ptr(from: &const rc_ptr<T>) {
        let strong = *from.block.strong;
        this.block = *from.block;
        (*this.block.strong) = strong + 1u;
    }
    //! Move
    rc_ptr(from: &rc_ptr<T>) {

    }
    //! Allocate a new `rc_ptr` owning `val`.
    fun new_rc_ptr(val: T) -> rc_ptr<T> {
        let block: &RcBlock<T> = mem_alloc<RcBlock<T>>();
        block.set(1u, val);
        return new rc_ptr<T>(block);
    }

    //! Release ownership; free block when count hits zero.
    fun release(this) {
        let old = *this.block.strong;
        if old == 0u {
            panic("double release");
        }
        let new_counter = old - 1u;
        (*this.block.strong) = new_counter;

        if new_counter == 0u {
            delete this.block;
        }
    }

    //! Return a const reference to the value.
    fun get(&this) -> &const T {
        return this.block.value;
    }

    //! Return a mutable reference to the value.
    fun get_mut(&this) -> &T {
        return this.block.value;
    }
}

extern len<T>(data: &[T]) -> uint64;

struct vector<T> {
public:
    data: [T];
    length: uint64;
public:
    vector(data: [T]) {
        this.length = len(&data);
        this.data = data;
    }
}

fun main() {
    let vec = new vector<int64>(new [int64; 3]);
    let rc_vec = rc_ptr::<vector<int64>>::new_rc_ptr(vec);
    // This should trigger the copy constructor
    let rc_vec_clone = rc_vec;
    println("Length of rc_vec: ");
    println(rc_vec.get().length);
    println("Length of rc_vec_clone: ");
    println(rc_vec_clone.get().length);
}