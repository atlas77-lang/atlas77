import "std/vector";
import "std/optional";
import "std/iter";
import "std/mem";

//There might be issues with ownership here...
//get_first() & get_second() might only work if K and V are std::copyable
//Maybe we should return references to K and V instead?
// Note: Constraints removed temporarily due to constraint propagation issues
// The _copy method requires K and V to be copyable anyway for dereferencing to work
public struct Pair<K, V> {
public:
    key: K;
    value: V;
    Pair(key: K, value: V) {
        this.key = key;
        this.value = value;
    }
    ~Pair() {
        delete this.key;
        delete this.value;
    }
    /// Copy constructor - creates a deep copy of the pair
    /// Note: K and V must be copyable types for this to work correctly
    fun _copy(&const this) -> Pair<K, V> {
        return new Pair<K, V>(*(this.key), *(this.value));
    }
    fun get_first(&const this) -> K {
        return *(this.key);
    }
    fun get_second(&const this) -> V {
        return *(this.value);
    }
    /// Consumes this pair and returns a new pair with swapped key and value
    fun swap(this) -> Pair<V, K> {
        let value = this.value;
        let key = this.key;
        delete_from_ref(&this);
        return new Pair<V, K>(value, key);
    }
}
/// A simple map implementation using two parallel arrays.
/// This will not make into production stdlib, I just wanted to see what could
/// be done with the current language features.
//NB: Only works for primitive K types that support equality comparison
public struct Map<K, V> {
private:
    keys: Vector<K>;
    values: Vector<V>;
public:
    Map() {
        this.keys = new Vector<K>(new [K; 0]);
        this.values = new Vector<V>(new [V; 0]);
    }
    ~Map() {
        delete this.keys;
        delete this.values;
    }
    /// Copy constructor - creates a deep copy of the map
    Map(from: &const Map<K, V>) {
        this.keys = *from.keys;
        this.values = *from.values;
    }
    /// Retrieves the value associated with the given key.
    /// Returns None if the key does not exist.
    fun get(&const this, key: K) -> optional<&const V> {
        let i: uint64 = 0u;
        while i < *this.keys.length {
            if this.keys.get(i) == &key {
                let value = this.values.get(i);
                return optional<&const V>::of(value);
            }
            i = i + 1u;
        }
        return optional<&const V>::empty();
    }
    /// Retrieves a mutable reference to the value associated with the given key.
    /// Returns None if the key does not exist.
    fun get_mut(&this, key: K) -> optional<&V> {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == &key {
                let value = this.values.get_mut(i);
                return optional<&V>::of(value);
            }
            i = i + 1u;
        }
        return optional<&V>::empty();
    }
    /// Inserts a key-value pair into the map.
    /// If the key already exists, updates its value.
    fun insert(&this, key: K, value: V) {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == &key {
                // Key exists, update value
                this.values.set(i, value);
                return;
            }
            i = i + 1u;
        }
        // Key does not exist, add new key-value pair
        this.keys.push(key);
        this.values.push(value);
    }
    /// Removes a key-value pair from the map by key.
    /// If the key does not exist, does nothing.
    fun remove(&this, key: K) {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == &key {
                // Key found, remove key and value by shifting elements
                let j: uint64 = i;
                while j + 1u < this.keys.length {
                    this.keys.set(j, this.keys.take(j + 1u));
                    this.values.set(j, this.values.take(j + 1u));
                    j = j + 1u;
                }
                // Decrease lengths
                this.keys.length = this.keys.length - 1u;
                this.values.length = this.values.length - 1u;
                return;
            }
            i = i + 1u;
        }
        return;
    }
    /// Returns the number of key-value pairs in the map.
    fun size(&this) -> uint64 {
        return this.keys.length;
    }

    fun into_iter(this) -> Iter<Pair<K, V>> {
        let size = this.keys.length;
        let pairs = Vector<Pair<K, V>>::with_capacity(size);
        let i = 0u;
        while i < size {
            // Create pair directly from array access to avoid take() issues
            let key_ref = this.keys.get(i);
            let value_ref = this.values.get(i);
            // Copy the values (which will properly deep-copy for object types)
            let key = *key_ref;
            let value = *value_ref;
            let pair = new Pair<K, V>(key, value);
            pairs.push(pair);
            i = i + 1u;
        }
        delete this;
        return new Iter<Pair<K, V>>(pairs);
    }

    fun keys(&const this) -> Iter<&const K> {
        let size = *this.keys.length;
        let keys_vec = Vector<&const K>::with_capacity(size);
        let i = 0u;
        while i < size {
            let key_ref = this.keys.get(i);
            keys_vec.push(key_ref);
            i = i + 1u;
        }
        return new Iter<&const K>(keys_vec);
    }

    fun values(&const this) -> Iter<&const V> {
        let size = *this.values.length;
        let values_vec = Vector<&const V>::with_capacity(size);
        let i = 0u;
        while i < size {
            let value_ref = this.values.get(i);
            values_vec.push(value_ref);
            i = i + 1u;
        }
        return new Iter<&const V>(values_vec);
    }
}
