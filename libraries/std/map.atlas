import "std/vector";
import "std/optional";
import "std/iter";

//There might be issues with ownership here...
//get_first() & get_second() might only work if K and V are std::copyable
//Maybe we should return references to K and V instead?
public struct Pair<K, V> {
public:
    key: K;
    value: V;
    Pair(key: K, value: V) {
        this.key = key;
        this.value = value;
    }
    ~Pair() {
        delete this.key;
        delete this.value;
    }
    fun get_first(&this) -> K {
        return this.key;
    }
    fun get_second(&this) -> V {
        return this.value;
    }
    /// Consumes this pair and returns a new pair with swapped key and value
    fun swap(this) -> Pair<V, K> {
        return new Pair<V, K>(this.value, this.key);
    }
}
/// A simple map implementation using two parallel arrays.
/// This will not make into production stdlib, I just wanted to see what could
/// be done with the current language features.
//NB: Only works for primitive K types that support equality comparison
public struct Map<K, V> {
private:
    keys: Vector<K>;
    values: Vector<V>;
public:
    Map() {
        this.keys = new Vector<K>(new [K; 0]);
        this.values = new Vector<V>(new [V; 0]);
    }
    ~Map() {
        delete this.keys;
        delete this.values;
    }
    /// Retrieves the value associated with the given key.
    /// Returns None if the key does not exist.
    fun get(&this, key: K) -> optional<&const V> {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == key {
                let value = this.values.get(i);
                return optional<&const V>::of(&value);
            }
            i = i + 1u;
        }
        return optional<&const V>::empty();
    }
    /// Retrieves a mutable reference to the value associated with the given key.
    /// Returns None if the key does not exist.
    fun get_mut(&this, key: K) -> optional<&V> {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == key {
                let value = this.values.get(i);
                return optional<&V>::of(&value);
            }
            i = i + 1u;
        }
        return optional<&V>::empty();
    }
    /// Inserts a key-value pair into the map.
    /// If the key already exists, updates its value.
    fun insert(&this, key: K, value: V) {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == key {
                // Key exists, update value
                this.values.set(i, value);
                return;
            }
            i = i + 1u;
        }
        // Key does not exist, add new key-value pair
        this.keys.push(key);
        this.values.push(value);
    }
    /// Removes a key-value pair from the map by key.
    /// If the key does not exist, does nothing.
    fun remove(&this, key: K) {
        let i: uint64 = 0u;
        while i < this.keys.length {
            if this.keys.get(i) == key {
                // Key found, remove key and value by shifting elements
                let j: uint64 = i;
                while j + 1u < this.keys.length {
                    this.keys.set(j, this.keys.get(j + 1u));
                    this.values.set(j, this.values.get(j + 1u));
                    j = j + 1u;
                }
                // Decrease lengths
                this.keys.length = this.keys.length - 1u;
                this.values.length = this.values.length - 1u;
                return;
            }
            i = i + 1u;
        }
        return;
    }
    /// Returns the number of key-value pairs in the map.
    fun size(&this) -> uint64 {
        return this.keys.length;
    }

    fun into_iter(this) -> Iter<Pair<K, V>> {
        let pairs = Vector<Pair<K, V>>::with_capacity(this.keys.length);
        let i: uint64 = 0u;
        while i < this.keys.length {
            let pair = new Pair<K, V>(this.keys.get(i), this.values.get(i));
            pairs.push(pair);
            i = i + 1u;
        }
        // Clean up the map now that we've extracted all pairs
        delete this;
        return new Iter<Pair<K, V>>(pairs);
    }
}
