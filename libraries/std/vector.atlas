import "std/io";
import "std/iter";
// We need to import std/mem to use memcpy for the try_take function
import "std/mem";

public extern len<T>(data: &const [T]) -> uint64;
public extern slice<T>(data: &const [T], start: uint64, end: uint64) -> [T];

public struct Vector<T> {
private:
    data: [T];
public:
    length: uint64;
    capacity: uint64;

    Vector(data: [T]) {
        this.length = len(&data);
        this.capacity = this.length;
        this.data = data;
    }
    ~Vector() {
        // We shouldn't delete anything outside of data[0..length]
        let i: uint64 = 0u;
        while i < this.length {
            delete this.data[i];
            i = i + 1u;
        }
        //Well, if we delete data itself, we get an error for some reason ... so we won't do that yet.
    }
    fun _copy(&const this) -> Vector<T> {
        let new_data = slice(&this.data, 0u, *this.length);
        return new Vector<T>(new_data);
    }
    /// Creates a new Vector with the specified capacity.

    fun with_capacity(capacity: uint64) -> Vector<T> {
        let vec = new Vector<T>(new [T; capacity]);
        vec.length = 0u;
        return vec;
    }

    fun get(&this, index: uint64) -> &const T {
        if index >= this.length {
            panic("Index out of bounds");
        }
        return &(this.data[index]);
    }

    fun get_mut(&this, index: uint64) -> &T {
        if index >= this.length {
            panic("Index out of bounds");
        }
        return &(this.data[index]);
    }

    fun set(&this, index: uint64, val: T) {
        if index >= this.length {
            panic("Index out of bounds");
        }
        this.data[index] = val;
    }

    /// A function that has a "self" parameter is a method of the struct
    /// and is called like this: "vector_instance.function_name()"
    fun push(&this, val: T) {
        if this.length >= this.capacity {
            // Resize
            let new_capacity: uint64 = 0u;
            if this.capacity == 0u {
                new_capacity = 1u;
            } else {
                new_capacity = this.capacity * 2u;
            }
            let new_data = new [T; new_capacity];
            let i: uint64 = 0u;
            while i < this.length {
                new_data[i] = this.data[i];
                i = i + 1u;
            }
            this.data = new_data;
            this.capacity = new_capacity;
        }
        this.data[this.length] = val;
        this.length = this.length + 1u;
    }
    
    fun pop(&this) -> T {
        if this.length == 0u {
            panic("Cannot pop from an empty vector");
        }
        this.length = this.length - 1u;
        let popped_val = this.data[this.length];
        return popped_val;
    }

    /// Consumes the vector and returns an iterator over its elements.
    /// The vector cannot be used after calling this method.
    fun into_iter(this) -> Iter<T> {
        return new Iter<T>(this);
    }
    /// Takes an element out of the vector at the specified index,
    /// shifting subsequent elements to the left.
    fun take(&this, index: uint64) -> T {
        // Public method to take an element out of the vector
        return this.try_take(index);
    }

private:
    fun try_take(&this, index: uint64) -> T {
        if index >= this.length {
            panic("Index out of bounds");
        }
        // Use memcpy to create a copy of the element at index
        let val: &const T = this.get(index);
        let item: T = memcpy(val);
        // Shift elements to fill the gap
        let i: uint64 = index;
        while i + 1u < this.length {
            this.data[i] = this.data[i + 1u];
            i = i + 1u;
        }
        this.length = this.length - 1u;
        return item;
    }
}

fun main() {
    let vec: Vector<uint64> = Vector<uint64>::with_capacity(2u);
    vec.push(10u);
    vec.push(20u);
    vec.push(30u);
    print("Vector length after pushes: ");
    println(vec.length);
    let val: uint64 = vec.take(1u);
    print("Taken value at index 1: ");
    println(val);
    print("Vector length after take: ");
    println(vec.length);
    let popped: uint64 = vec.pop();
    print("Popped value: ");
    println(popped);
    print("Vector length after pop: ");
    println(vec.length);
}
// Well, this is a bug, it shouldn't be allowed to return a reference to a local variable
private fun hehe() -> &const int64 {
    let stuff = [1, 2, 3, 4, 5];
    return &(stuff[2u]);
}

