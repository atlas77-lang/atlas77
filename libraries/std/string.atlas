/// String library for Atlas `std::string`
///
/// Provides a String struct with various string manipulation functions.

import "std/vector";
import "std/iter";

/// Takes a `&const string` and returns its length as `uint64`.
public extern str_len(s: &const string) -> uint64;
/// Takes a `string` and returns a new `string` with leading and trailing whitespace removed.
public extern trim(s: string) -> string;
/// Takes a `string` and returns a new `string` converted to uppercase.
public extern to_upper(s: string) -> string;
/// Takes a `string` and returns a new `string` converted to lowercase.
public extern to_lower(s: string) -> string;
/// Takes a `&string` and a `&string` separator, and returns an array of `string` split by the separator.
public extern split(s: &string, sep: &string) -> [string];
/// Compares two constant strings lexicographically.
public extern str_cmp(s1: &const string, s2: &const string) -> uint64;
/// Converts a `&const string` to an array of `char`.
public extern to_chars(s: &const string) -> [char];
/// Converts an array of `char` to a `string`.
public extern from_chars(s: [char]) -> string;


public struct String {
public:
    s: string;
    len: uint64;

    String(s: string) {
        this.s = s;
        this.len = str_len(&s);
    }

    ~String() {
        delete this.s;
    }

    /// Copy constructor - creates a deep copy of the string
    fun _copy(&const this) -> String {
        return new String(*this.s);
    }

    fun from_chars(s: [char]) -> String {
        return new String(from_chars(s));
    }

    /// Example: String::str_len("Hello") -> 5
    fun str_len(s: &const string) -> uint64 {
        return str_len(s);
    }

    fun len(&this) -> uint64 {
        return this.len;
    }

    fun is_empty(&this) -> bool {
        return this.len == 0u;
    }
    //todo: implement as_bytes
    //fun as_bytes(this) -> [uint8] {}
    fun concat(&this, other: String) -> String {
        //I should really implement the <- operator for copying objects
        let self_chars = to_chars(&this.s);
        let other_chars = to_chars(&other.s);
        let res = new [char; len(&self_chars) + len(&other_chars)];
        let i = 0u;
        while i < len(&self_chars) {
            res[i] = self_chars[i];
            i = i + 1u;
        }
        return new String(from_chars(res));
    }

    fun push(&this, c: char) -> unit {
        //Same... I should implement the <- operator
        let self_chars = to_chars(&this.s);
        let res = new [char; len(&self_chars) + 1u];
        let i = 0u;
        while i < len(&self_chars) {
            res[i] = self_chars[i];
            i = i + 1u;
        }
        res[i] = c;
        this.s = from_chars(res);
        this.len = str_len(&this.s);
        return;
    }

    fun push_str(&this, s: String) -> unit {
        let self_chars = to_chars(&this.s);
        let s_chars = to_chars(&s.s);
        let res = new [char; len(&self_chars) + len(&s_chars)];
        let i = 0u;
        while i < len(&self_chars) {
            res[i] = self_chars[i];
            i = i + 1u;
        }
        let j = 0u;
        while j < len(&s_chars) {
            res[i] = s_chars[j];
            i = i + 1u;
            j = j + 1u;
        }
        this.s = from_chars(res);
        this.len = str_len(&this.s);
        return;
    }

    fun find(&this, sub_string: String) -> uint64 {
        let res = -1;
        let i = 0u;
        let j = 0u;
        let self_chars = to_chars(&this.s);
        let sub_chars = to_chars(&sub_string.s);
        while i < len(&self_chars) && res == -1 {
            if self_chars[i] == sub_chars[j] {
                const size_sub_chars: uint64 = len(&sub_chars) - 1u;
                if j == size_sub_chars {
                    res = i as int64 - j as int64;
                }
                j = j + 1u;
            } else {
                j = 0u;
            }
            i = i + 1u;
        }
        return res as uint64;
    }

    fun get(&this, i: uint64) -> char {
        return this.s[i];
    }

    fun set(&this, i: uint64, c: char) -> unit {
        this.s[i] = c;
        return;
    }

    fun to_str(&this) -> string {
        return this.s;
    }

    fun to_chars(&this) -> [char] {
        return to_chars(&this.s);
    }

    fun to_upper(&this) -> String {
        return new String(to_upper(this.s));
    }

    fun to_lower(&this) -> String {
        return new String(to_lower(this.s));
    }

    fun trim(&this) -> String {
        return new String(trim(this.s));
    }

    fun split(&this, sep: string) -> [String] {
        let s: [string] = split(&this.s, &sep);
        let i = 0u;
        let res = new [String; len(&s)];
        while i < len(&s) {
            res[i] = new String(s[i]);
            i = i + 1u;
        }
        return res;
    }

    fun into_iter(this) -> Iter<char> {
        return Iter<char>::from_string(this);
    }
}
