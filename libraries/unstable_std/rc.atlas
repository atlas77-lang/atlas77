import "std/io";

private struct RCBlock<T> {
public:
    strong: uint64;
    value: T;
    RCBlock(strong: uint64, value: T) {
        this.strong = strong;
        this.value = value;
    }
}

// Ref-counted pointer implementation
public struct rc_ptr<T> {
private:
    block: &RCBlock<T>;
    /// Private constructor
    /// Used internally to create a rc_ptr from an existing RCBlock
    rc_ptr(block: &RCBlock<T>) {
        this.block = block;
    }
public:
    // custom destructor
    ~rc_ptr() {
        this.release();
    }
    fun new_rc_ptr(val: T) -> rc_ptr<T> {
        let block = new RCBlock<T>(1, val);
        return rc_ptr<T>(&block);
    }

    fun clone(this) -> rc_ptr<T> {
        this.block.strong = this.block.strong + 1 as uint64;
        return new rc_ptr<T>(this.block);
    }

    fun release(this) {
        let old = this.block.strong;
        if old == 0 {
            panic("double release");
        }
        let new_ = old - 1 as uint64;
        this.block.strong = new_;

        if new_ == 0 {
            delete this.block; //Shouldn't we also free the ``rc_ptr`` itself?
        }
    }

    fun get(this) -> &const T {
        return &const this.block.value;
    }

    fun get_mut(this) -> &T {
        return &this.block.value;
    }
}