import "std/io";
import "std/vector";
import "src/lexer";
import "std/string";
import "std/iter";

#[std::non_copyable]
public struct BrainFuckInterpreter {
public:
    cells: [uint64];
    pointer: uint64;

    BrainFuckInterpreter() {
        this.cells = new [uint64; 50];
        let i: uint64 = 0u;
        while i < 50u {
            this.cells[i] = 0u;
            i = i + 1u;
        }
        this.pointer = 0u;
    }
    ~BrainFuckInterpreter() {
        delete this.cells;
    }
    fun run(&this, tokens: Vector<Token>) {
        println("Running BrainFuck Interpreter...");
        let iterator: Iter<Token> = tokens.into_iter();
        while iterator.has_next() {
            let token_next = iterator.next();
            let token = token_next.value();
            if token.kind == TokenKind::SHIFT_RIGHT {
                this.pointer = this.pointer + 1u;
            } else if token.kind == TokenKind::SHIFT_LEFT {
                this.pointer = this.pointer - 1u;
            } else if token.kind == TokenKind::INCREMENT {
                this.cells[this.pointer] = this.cells[this.pointer] + 1u;
            } else if token.kind == TokenKind::DECREMENT {
                this.cells[this.pointer] = this.cells[this.pointer] - 1u;
            } else if token.kind == TokenKind::OUTPUT {
                let char_value = this.cells[this.pointer] as char;
                print(char_value);
            } else if token.kind == TokenKind::INPUT {
                let input = input();
                let input_char = input as char;
                this.cells[this.pointer] = input_char as uint64;
            } else if token.kind == TokenKind::LOOP_START {
                // Let's implement loops handling now
                if this.cells[this.pointer] == 0u {
                    // Skip to the matching LOOP_END
                    let loop_counter: uint64 = 1u;
                    while loop_counter > 0u && iterator.has_next() {
                        let next_token = iterator.next();
                        let kind = next_token.value().kind;
                        if kind == TokenKind::LOOP_START {
                            loop_counter = loop_counter + 1u;
                        } else if kind == TokenKind::LOOP_END {
                            loop_counter = loop_counter - 1u;
                        }
                    }
                }
            } else if token.kind == TokenKind::LOOP_END {
                // Go back to the matching LOOP_START
                if this.cells[this.pointer] != 0u {
                    let loop_counter: uint64 = 1u;
                    // Copy and reverse the iterator to go backwards
                    let reverse_iterator = iterator.reversed();
                    while loop_counter > 0u && reverse_iterator.has_next() {
                        let prev_token = reverse_iterator.next();
                        let kind = prev_token.value().kind;
                        if kind == TokenKind::LOOP_END {
                            loop_counter = loop_counter + 1u;
                        } else if kind == TokenKind::LOOP_START {
                            loop_counter = loop_counter - 1u;
                        }
                    }
                    // Move the main iterator to the position after LOOP_START
                    iterator = reverse_iterator.rev();
                }                
            }
        }
        println("    <= Output complete.");
    }

}
