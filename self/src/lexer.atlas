import "std/string";
import "std/vector";

public enum TokenKind {
    SHIFT_RIGHT;
    SHIFT_LEFT;
    INCREMENT;
    DECREMENT;
    OUTPUT;
    INPUT;
    LOOP_START;
    LOOP_END;
}

public union TokenValue {
    value: string;
    none: unit;
}

public struct Token {
public:
    kind: TokenKind;
    value: String;
    Token(kind: TokenKind, value: String) {
        this.kind = kind;
        this.value = value;
    }
    ~Token() {
        //delete this.value;
    }
    fun is_equal(this, other: Token) -> bool {
        return this.kind == other.kind;
    }
}

public struct Lexer {
private:
    source: String;
public:
    Lexer(source: String) {
        this.source = source;
    }
    ~Lexer() {
        // Weirdly enough, "Destroying Lexer..." should also get deleted, so the compiler should rewrite this as:
        // let __temp = this.source;
        // println("Destroying Lexer...");
        // delete __temp;
        // delete this.source;
        // Or, `println` moves the ownership of "Destroying Lexer..." string literal, and we assume println will delete it?
        println("Destroying Lexer...");
        delete this.source;
    }
    fun tokenize(this) -> Vector<Token> {
        let tokens = Vector<Token>::with_capacity(this.source.len());
        let src_iter = this.source.into_iter();
        while src_iter.has_next() {
            const c: char = src_iter.next().unwrap();
            if c == '>' {
                tokens.push(new Token(TokenKind::SHIFT_RIGHT, new String(">")));
            } else if c == '<' {
                tokens.push(new Token(TokenKind::SHIFT_LEFT, new String("<")));
            } else if c == '+' {
                tokens.push(new Token(TokenKind::INCREMENT, new String("+")));
            } else if c == '-' {
                tokens.push(new Token(TokenKind::DECREMENT, new String("-")));
            } else if c == '.' {
                tokens.push(new Token(TokenKind::OUTPUT, new String(".")));
            } else if c == ',' {
                tokens.push(new Token(TokenKind::INPUT, new String(",")));
            } else if c == '[' {
                tokens.push(new Token(TokenKind::LOOP_START, new String("[")));
            } else if c == ']' {
                tokens.push(new Token(TokenKind::LOOP_END, new String("]")));
            } else {
                // Ignore unknown characters for now
            }
        }
        return tokens;
    }
}
