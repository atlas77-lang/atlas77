import "std/string";
import "std/vector";

public enum TokenKind {
    SHIFT_RIGHT;
    SHIFT_LEFT;
    INCREMENT;
    DECREMENT;
    OUTPUT;
    INPUT;
    LOOP_START;
    LOOP_END;
}

public struct Token {
public:
    kind: TokenKind;
    value: String;
    Token(kind: TokenKind, value: String) {
        this.kind = kind;
        this.value = value;
    }
    //~Token() {}
    fun is_equal(this, other: Token) -> bool {
        return this.kind == other.kind;
    }
}

//Let's try to lex brainfuck as a start
public fun lex(source: String) -> Vector<Token> {
    let tokens = new Vector<Token>(new [Token; 0]); //Later there will be a `Vector<T>::with_capacity` function to make this cleaner
    let i: uint64 = 0_uint64;
    while i < source.len() {
        let c = source.get(i);
        if c != ' ' {
            // Not whitespace
            if c == '>' {
                tokens.push(new Token(TokenKind::SHIFT_RIGHT, new String(">")));
            } else if c == '<' {
                tokens.push(new Token(TokenKind::SHIFT_LEFT, new String("<")));
            } else if c == '+' {
                tokens.push(new Token(TokenKind::INCREMENT, new String("+")));
            } else if c == '-' {
                tokens.push(new Token(TokenKind::DECREMENT, new String("-")));
            } else if c == '.' {
                tokens.push(new Token(TokenKind::OUTPUT, new String(".")));
            } else if c == ',' {
                tokens.push(new Token(TokenKind::INPUT, new String(",")));
            } else if c == '[' {
                tokens.push(new Token(TokenKind::LOOP_START, new String("[")));
            } else if c == ']' {
                tokens.push(new Token(TokenKind::LOOP_END, new String("]")));
            } else {
                // Unknown character, ignore for now
            }
        }
        i = i + 1_uint64;
    }
    return tokens;
}