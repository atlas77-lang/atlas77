// Used internally by the compiler to test every features
// It doesn't have any specific meaning

import "std/box";
import "std/fs";
import "std/io";
import "std/iter";
import "std/map";
import "std/math";
import "std/optional";
import "std/expected";
import "std/string";
import "std/time";
import "std/vector";

// Generic identity function
fun identity<T>(value: T) -> T {
    return value;
}

// Generic swap function
fun swap_values<X, Y>(a: X, b: Y) -> Pair<Y, X> {
    return new Pair<Y, X>(b, a);
}

// Generic container type
struct Container<T> {
public:
    value: T;

    Container(val: T) {
        this.value = val;
    }

    fun get(&this) -> T {
        return this.value;
    }

    fun set(&this, new_val: T) {
        this.value = new_val;
    }

    fun _copy(&const this) -> Container<T> {
        return new Container<T>(*this.value);
    }
}

// Generic pair wrapper (different from std Map's Pair)
struct GenericTuple<A, B> {
public:
    first: A;
    second: B;

    GenericTuple(a: A, b: B) {
        this.first = a;
        this.second = b;
    }

    fun _copy(&const this) -> GenericTuple<A, B> {
        return new GenericTuple<A, B>(*this.first, *this.second);
    }

    fun first_value(&this) -> A {
        return this.first;
    }

    fun second_value(&this) -> B {
        return this.second;
    }

    fun swap_tuple(this) -> GenericTuple<B, A> {
        return new GenericTuple<B, A>(this.second, this.first);
    }
}

fun main() {
    // Testing generic identity function
    print("Identity int64: ");
    println(identity<int64>(42));
    print("Identity string: ");
    println(identity<string>("Hello Generics"));
    
    // Testing generic swap function
    let swapped_pair: Pair<string, int64> = swap_values<int64, string>(100, "test");
    print("Swapped first (string): ");
    println(swapped_pair.get_first());
    print("Swapped second (int64): ");
    println(swapped_pair.get_second());
    println("");

    // Testing generic Container struct
    let int_container: Container<int64> = new Container<int64>(99);
    print("Container value: ");
    println(int_container.get());
    int_container.set(88);
    print("After set: ");
    println(int_container.get());
    let string_container: Container<string> = new Container<string>("Generic Container");
    print("String container: ");
    println(string_container.get());
    println("");

    // Testing generic GenericTuple struct
    let tuple: GenericTuple<int64, string> = new GenericTuple<int64, string>(42, "answer");
    print("Tuple first: ");
    println(tuple.first_value());
    print("Tuple second: ");
    println(tuple.second_value());
    let tuple_swapped: GenericTuple<string, int64> = tuple.swap_tuple();
    print("Swapped tuple first (string): ");
    println(tuple_swapped.first_value());
    print("Swapped tuple second (int64): ");
    println(tuple_swapped.second_value());
    println("");

    // Testing generics with Pair from Map
    let p: Pair<int64, String> = new Pair<int64, String>(42, new String("The answer"));
    println(p.get_first());
    println(p.get_second().s);
    let swapped: Pair<String, int64> = p.swap();
    println(swapped.get_first().s);
    println(swapped.get_second());
    println("");
    
    // Testing vectors
    let vec = Vector<int64>::with_capacity(10u);
    let i = 0;
    while i < 10 {
        vec.push(i);
        i = i + 1;
    }
    print("Vector length: ");
    println(vec.length);
    let iter: Iter<int64> = vec.into_iter();
    print("Iterator over vector:");
    while iter.has_next() {
        print("Iteration - ");
        let val: optional<int64> = iter.next();
        print("Value: ");
        println(val.value());
    }
    println("");

    // TODO: Map iteration is currently broken due to memcpy issue with strings in generic code
    // When Vector<string>.take() is called, it uses memcpy which creates shallow copies
    // This causes the Pair to contain dangling pointers after the Map is deleted
    // See: libraries/std/vector.atlas line 117 - try_take uses memcpy
    println("Map iteration test skipped (known issue with memcpy and strings in generics)");

    // TODO: Container<string> iteration also has the same const reference field access bug
    println("Container iteration test skipped (same const reference field issue)");

    // Testing file system
    let path = "test_file.txt";
    let file = new File(path);
    file.write("Hello, Atlas!\n");
    //Call the destructor to close the file
    delete file;
    let file2 = new File(path);
    let content = file2.read();
    print("File content: ");
    println(content);
    // Clean up
    file2.remove();
    delete file2;
}