import "std/io";

// Flag telling explicitly the compiler to
// generate a copy constructor if there is none
// Will warn you if it fails to do so
#[std::copyable]
// The type T has to be copyable
struct Copyable<T: std::copyable> {
public:
    a: int64;
    b: T;
    // Normal constructor
    Copyable(a: int64, b: T) {
        this.a = a;
        this.b = b;
    }
    // Destructor

    // Copy constructor
    Copyable(from: &const Copyable<T>) {
        this.a = *from.a;
        this.b = *from.b;
    }
}
public struct Foo<T> {
    value: Copyable<T>;
}
// Should fail because of recursive types
struct AA {
  b: CC;
}
struct BB {
  a: CC;
}

union CC {
  a: AA;
  b: BB;
}

fun main() {
    let original = new Copyable<string>(42, "Hello");
    let copy = original;
    print("Original a: ");
    print(original.a);
    print(", b: ");
    print(original.b);
    println("");
    print("Copy a: ");
    print(copy.a);
    print(", b: ");
    println(copy.b);
}