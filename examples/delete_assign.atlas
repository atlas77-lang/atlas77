import "std/io";

struct Test {
public:
    s: string;
    Test(s: string) {
        this.s = s;
    }
    fun set_s(&this, s: string) {
        // this.s should be deleted here before reassignment
        this.s = s;
    }
}

union TempTest {
    value: Test;
    something: int64;
}

fun main() {
    let s = "Hello, World!";
    // s should be deleted here before reassignment
    s = "Goodbye, World!"; 
    println(s);

    let t = new Test("Initial");
    t.set_s("Updated");
    println(t.s);

    let arr = [new Test("One"), new Test("Two"), new Test("Three")];
    let i = 0u;
    while i < 3u {
        // arr[i] should be deleted here before reassignment
        arr[i] = arr[(i + 1u) % 3u];
        arr[i] = new Test("Modified");
        arr[i].set_s("Modified");
        println(arr[i].s);
        i = i + 1u;
    }

    let un = TempTest { 
        .something =  42 
    };
    un = TempTest { 
        .value = new Test("From Union") 
    };



    let foo = new NonCopyable();
    while true {
        let borrowed_foo = &foo;
        // This should error: use after free
        delete foo;
    }

    let foo2 = new NonCopyable();
    while true {
        let borrowed_foo2 = &foo2;
        // This should error: use after free
        delete foo2;
        // Maybe this should work?
        foo2 = new NonCopyable();
    }

    let foo3 = new NonCopyable();
    let borrowed_foo3 = &foo3;
    // Can use borrowed_foo3 here
    delete foo3;
    // Can't use borrowed_foo3 here

    let foo4 = new NonCopyable();
    while true {
        // This already error properly
        let borrowed_foo4 = foo4;
    }

}

#[std::non_copyable]
struct NonCopyable {
public:
    data: string;
    NonCopyable() {
        this.data = "Non-Copyable Data";
    }
}