import "std/io";
// A non-copyable resource (like a file handle or unique pointer)
#[std::non_copyable]
struct UniqueResource {
public:
    id: int64;
    
    UniqueResource(id: int64) {
        println("Resource created");
        this.id = id;
    }
    
    ~UniqueResource() {
        println("Resource destroyed");  // RAII cleanup!
    }
}

// A copyable struct
struct Copyable {
public:
    value: int64;
    
    Copyable(value: int64) {
        this.value = value;
    }

    ~Copyable() {
        print("Copyable destroyed with value: ");
        println(this.value);
    }

    Copyable(from: &const Copyable) {
        this.value = *from.value;
    }
}

fun mutate(ref: &int64) {
    (*ref) = *ref * 2;  // Dereference and modify
}

fun read_only(ref: &const int64) {
    println(*ref);
    // (*ref) = 10;  // ❌ Compile error: can't mutate const ref
}

fun consume(resource: UniqueResource) {
    println("Consuming resource");
}  // resource destroyed here

fun main() {
    // === Move semantics (no _copy = move-only) ===
    println("=== Move-only struct test ===");
    let res = new UniqueResource(1);
    consume(res);   // Ownership MOVED to function
    // println(res.id);  // ❌ Compile error: use after move!

    // === Copy semantics (has _copy = auto-copy) ===
    println("=== Copyable struct test ===");
    let a = new Copyable(42);
    let b = a;       // Copies! (not last use of 'a')
    let c = a;       // Last use - could move or copy
    println(b.value);  // 42
    
    // === Mutable references ===
    println("=== Mutable reference test ===");
    let x = 10;
    println(x);      // 10
    mutate(&x);      // Pass mutable reference
    println(x);      // 20
    mutate(&x);      // Modify in place again
    println(x);      // 40 - modified in place!
    
    // === Const references ===
    println("=== Const reference test ===");
    let y = 100;
    read_only(&y);   // Borrow without transferring ownership
    read_only(&y);   // Can borrow multiple times
    println(y);      // Still valid!
}