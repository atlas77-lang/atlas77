import "std/io";
// A non-copyable resource (like a file handle or unique pointer)
struct UniqueResource {
public:
    id: int64;
    
    UniqueResource(id: int64) {
        println("Resource created");
        this.id = id;
    }
    
    ~UniqueResource() {
        println("Resource destroyed");  // RAII cleanup!
    }
}

// A copyable type - just implement _copy()!
struct Copyable {
public:
    value: int64;
    
    Copyable(value: int64) { this.value = value; }
    
    fun _copy(&const this) -> Copyable {
        println("Copying...");
        // Dereference to get the value and create a new instance
        return new Copyable(*this.value);
    }
}

fun mutate(ref: &int64) {
    *ref = *ref * 2;  // Dereference and modify
}

fun read_only(ref: &const int64) {
    println(*ref);
    // *ref = 10;  // ❌ Compile error: can't mutate const ref
}

fun consume(resource: UniqueResource) {
    println("Consuming resource");
}  // resource destroyed here

fun main() {
    // === Move semantics (no _copy = move-only) ===
    let res = new UniqueResource(1);
    consume(res);   // Ownership MOVED to function
    // println(res.id);  // ❌ Compile error: use after move!

    // === Copy semantics (has _copy = auto-copy) ===
    let a = new Copyable(42);
    let b = a;       // Copies! (not last use of 'a')
    let c = a;       // Last use - could move or copy
    println(b.value);  // 42
    
    // === Mutable references ===
    let x = 10;
    mutate(&x);      // Pass mutable reference
    println(x);      // 20 - modified in place!
    
    // === Const references ===
    let y = 100;
    read_only(&y);   // Borrow without transferring ownership
    read_only(&y);   // Can borrow multiple times
    println(y);      // Still valid!
}