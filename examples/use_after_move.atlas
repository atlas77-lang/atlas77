// ============================================================================
// Comprehensive Ownership and Move Semantics Tests
// ============================================================================
// This file tests the ownership pass's ability to detect:
// - Use-after-move via T&& (moveable reference) parameters
// - Double move errors
// - Move in loop warnings
// - Conditional move tracking
// ============================================================================

// Generic move function - takes T&& (moveable reference)
fun move<T: std::moveable>(val: T&&) -> T {
    return T::__mov_ctor(val);
}

// Generic copy function - takes T& (readonly reference)
fun copy<T: std::copyable>(val: T&) -> T {
    return T::copy(val);
}

// ============================================================================
// Test Struct with Move Constructor
// ============================================================================
struct Foo {
public:
    a: int64;
    Foo(value: int64) {
        this.a = value;
    }
    
    // Move constructor - required for std::moveable constraint
    Foo(dying_obj: Foo&&) {
        this.a = dying_obj.a;
    }
    
    // Copy constructor - required for std::copyable constraint
    Foo(from: const Foo&) {
        this.a = from.a;
    }
}

// ============================================================================
// Test Struct with Only Move Constructor (not copyable)
// ============================================================================
#[std::non_copyable]
struct UniqueResource {
public:
    handle: int64;
    
    // Move constructor only - cannot be copied
    UniqueResource(dying: UniqueResource&&) {
        this.handle = dying.handle;
    }
}

// External printf for output
extern fun printf<T>(fmt: string, val: T);

// ============================================================================
// Test 1: Basic Use-After-Move
// EXPECTED: Warning on line using 'f' after move
// ============================================================================
fun test_basic_use_after_move() {
    let f: Foo = new Foo(42);
    let f2: Foo = move<Foo>(f);
    // WARNING: use-after-move - 'f' was moved on line above
    printf("value: %ld\n", f.a);
}

// ============================================================================
// Test 2: Multiple Uses After Move  
// EXPECTED: Multiple warnings for each use of 'f' after move
// ============================================================================
fun test_multiple_uses_after_move() {
    let f: Foo = new Foo(100);
    let moved: Foo = move<Foo>(f);
    // WARNING: first use-after-move
    let a: int64 = f.a;
    // WARNING: second use-after-move
    printf("still using f: %ld\n", f.a);
}

// ============================================================================
// Test 3: Move Then Copy
// EXPECTED: Warning because trying to copy a moved-from value
// ============================================================================
fun test_move_then_copy() {
    let f: Foo = new Foo(200);
    let f2: Foo = move<Foo>(f);
    // WARNING: use-after-move - can't copy from moved value
    let f3: Foo = copy<Foo>(f);
}

// ============================================================================
// Test 4: Chained Moves
// EXPECTED: No warning - each move is from valid value
// ============================================================================
fun test_chained_moves() {
    let a: Foo = new Foo(1);
    let b: Foo = move<Foo>(a);
    let c: Foo = move<Foo>(b);
    let d: Foo = move<Foo>(c);
    // All moves are valid - each source was not previously moved
    printf("final value: %ld\n", d.a);
}

// ============================================================================
// Test 5: Custom Function Taking Moveable Reference
// EXPECTED: Warning when using 'f' after passing to take_ownership
// ============================================================================
fun take_ownership(val: Foo&&) -> int64 {
    return val.a;
}

fun test_custom_move_function() {
    let f: Foo = new Foo(300);
    let result: int64 = take_ownership(f);
    // WARNING: use-after-move - 'f' was moved by take_ownership
    printf("f.a after move: %ld\n", f.a);
}

// ============================================================================
// Test 6: Valid Usage - No Warnings
// EXPECTED: No warnings - proper ownership flow
// ============================================================================
fun test_valid_ownership() {
    let f1: Foo = new Foo(400);
    let f2: Foo = copy<Foo>(f1);  // Copy, original still valid
    printf("f1: %ld\n", f1.a);     // OK - f1 wasn't moved
    printf("f2: %ld\n", f2.a);     // OK - f2 is valid copy
    
    let f3: Foo = move<Foo>(f2);  // Move f2 to f3
    printf("f3: %ld\n", f3.a);     // OK - f3 is valid
}

// ============================================================================
// Test 7: Move in Conditional
// EXPECTED: Warning for possible use-after-move (conditionally moved)
// ============================================================================
fun test_conditional_move(condition: bool) {
    let f: Foo = new Foo(500);
    if condition {
        let moved: Foo = move<Foo>(f);
        printf("moved: %ld\n", moved.a);
    }
    // WARNING: possible use-after-move - 'f' may have been moved
    printf("f after conditional: %ld\n", f.a);
}

// ============================================================================
// Test 8: Move Unique Resource
// EXPECTED: No warnings - unique resource moved correctly
// ============================================================================
fun test_unique_resource() {
    let r1: UniqueResource = new UniqueResource(1);
    let r2: UniqueResource = move<UniqueResource>(r1);
    // WARNING: use-after-move - unique resource was moved
    printf("r1 handle: %ld\n", r1.handle);
}

// ============================================================================
// Main - Run all tests
// ============================================================================
fun main() {
    test_basic_use_after_move();
    test_multiple_uses_after_move();
    test_move_then_copy();
    test_chained_moves();
    test_custom_move_function();
    test_valid_ownership();
    test_conditional_move(true);
    test_unique_resource();
    test_from_variable();
}

// ============================================================================
// Test 9: Move from Variable via Moveable Reference
// EXPECTED: Warning when using 'f' after move via reference
// ============================================================================
fun test_from_variable() {
    let f: Foo = new Foo(600);
    let dying_foo: Foo&& = f;
    let f2: Foo = move<Foo>(dying_foo);
    // WARNING: use-after-move - 'f' was moved via dying_foo
    printf("f after move: %ld\n", f.a);
}
