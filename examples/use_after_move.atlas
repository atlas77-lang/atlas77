fun move<T: std::moveable>(val: &T) -> T {
    return T::__mov_ctor(val);
}

fun copy<T: std::copyable>(val: &T) -> T {
    return T::copy(val);
}

struct Foo {
public:
    a: int64;
    Foo(dying_obj: &Foo) {
        this.a = *dying_obj.a;
    }
}

extern printf<T>(fmt: string, val: T);

// Test use-after-move detection.
fun main() {
    let f: Foo = new Foo(10);
    let f2: Foo = move<Foo>(&f);
    // The following line should produce a use-after-move warning.
    let f3: Foo = copy<Foo>(&f);
    printf("%ld\n", f.a);
}