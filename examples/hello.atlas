extern fun printf<T>(fmt: string, val: T);
#[std::intrinsic]
extern fun size_of<T>() -> uint64;
fun main() {
    printf("Hello, %s\n", "Atlas!");
    test();
    let arr: [int64; 5u] = new [int64; 5u];
    arr[0u] = 10;
    arr[1u] = 20;
    arr[2u] = 30;
    arr[3u] = 40;
    arr[4u] = 50;
    let inline_arr = take_and_return_arr(arr);
    let i = 0u;
    while i < 5u {
        printf("inline_arr.data[%d]", i);
        printf("= %d\n", inline_arr.data[i]);
        i = i + 1u;
    }
    // Let's test this
    printf("size_of<[int64; 5u]> = %d\n", size_of<[int64; 5u]>());
}


fun test() {
    let a: [int64; 5] = new [int64; 5u];
    let b = a;
    b[0u] = 42;
    printf("a[0] = %d\n", a[0u]);
}

struct InlineArray5<T> {
public:
    data: [T; 5u];
    InlineArray5(data: [T; 5u]) {
        this.data = data;
    }
    InlineArray5() {
        this.data = new [T; 5u];
    }
}

fun take_and_return_arr(arr: [int64; 5u]) -> InlineArray5<int64> {
    let inline_arr = new InlineArray5<int64>(arr);
    let i = 0u;
    while i < 5u {
        inline_arr.data[i] = arr[i];
        i = i + 1u;
    }
    return inline_arr;
}

fun test_new_ref_model() {
    let a: int64 = 10;
    // Like in C++, no need to use '&' to create a reference
    // It is just an alias
    let lval_a: int64& = a;
    take_a_lval(lval_a);
    // Modifying 'a' through its name
    a = 20;
    take_a_lval(lval_a);
    lval_a = 30; // Modifying 'a' through its reference
    take_a_lval(lval_a);

    take_a_lval(25); // Should error lval to rvalue conversion
    let const_lval_a: const int64& = a;
    take_a_const_lval(const_lval_a);
    take_a_const_lval(50); // Should be OK: rvalue to const ref conversion

    let rval_a: int64&& = a;
    take_a_rval(rval_a);
    take_a_rval(100); // Should be OK: rvalue to rvalue ref conversion
}

fun take_a_rval(rval_a: int64&&) {
    printf("rval_a = %d\n", rval_a);
}

fun take_a_const_lval(const_lval_a: const int64&) {
    printf("const_lval_a = %d\n", const_lval_a);
    const_lval_a = 20; // Should error: cannot modify through const ref
}

fun take_a_lval(lval_a: int64&) {
    printf("lval_a = %d\n", lval_a);
}

fun take_and_return_ref(a: int64&) -> int64& {
    return a; // Should be OK
}

fun return_a_ref() -> int64& {
    let a: int64 = 10;
    return a; // Should error: returning reference to local variable
}

fun test_move_ref() {
    let nm = new NonMoveable(42);
    printf("nm.data = %d\n", *(nm.data));
    let nm_ref: NonMoveable&& = nm;
    printf("nm_ref.data = %d\n", *(nm_ref.data));
}

extern fun malloc<T>(size: uint64) -> ptr<T>;

struct NonMoveable {
public:
    data: ptr<int64>;
    NonMoveable(data: int64) {
        let data_ptr = malloc<int64>(size_of<int64>());
        this.data = data_ptr;
    }
    NonMoveable(from: NonMoveable&&) {
        this.data = from.data;
        from.data = null;
    }
}

