import "std/list"
// Miscellaneous functions for raw strings
extern str_len(s: Str): uint64
extern trim(s: Str): Str
extern to_upper(s: Str): Str
extern to_lower(s: Str): Str
extern split(s: Str, sep: Str): Array[Str]
extern str_cmp(s1: Str, s2: Str): Int64
extern to_chars(s: Str): Array[Char]
extern from_chars(s: [Char]): Str


@public
struct String {
    var s: Str
    var len: UInt64

    String(s: Str) {
        self.s = s;
        self.len = len(s);
    }
    ~String() {}
    fun from_chars(s: [Char]) -> String {
        return new String(from_chars(s));
    }
    /// Example: String::str_len("Hello") -> 5
    fun str_len(s: Str) -> uint64 {
        return str_len(s);
    }

    fun len(self) -> uint64 {
        return self.len;
    }
    fun is_empty(self) -> bool {
        return self.len == 0 as uint64;
    }
    //todo: implement as_bytes
    //fun as_bytes(self) -> [uint8] {}
    fun concat(self, other: String) -> String {
        //I should really implement the <- operator for copying objects
        let self_chars = to_chars(self.s);
        let other_chars = to_chars(other.s);
        let res = new [Char; len(self_chars) + len(other_chars)];
        let i = 0;
        while i < len(self_chars) {
            res[i] = self_chars[i];
            i = i + 1;
        }
    }
    fun push(self, c: Char) -> unit {
        //Same... I should implement the <- operator
        let self_chars = to_chars(self.s);
        let res = new [Char; len(self_chars) + 1];
        let i = 0;
        while i < len(self_chars) {
            res[i] = self_chars[i];
            i = i + 1;
        }
        res[i] = c;
        self.s = from_chars(res);
        self.len = str_len(self.s);
        return;
    }
    fun push_str(self, s: String) -> unit {
        let self_chars = to_chars(self.s);
        let s_chars = to_chars(s.s);
        let res = new [Char; len(self_chars) + len(s_chars)];
        let i = 0;
        while i < len(self_chars) {
            res[i] = self_chars[i];
            i = i + 1;
        }
        let j = 0;
        while j < len(s_chars) {
            res[i] = s_chars[j];
            i = i + 1;
            j = j + 1;
        }
        self.s = from_chars(res);
        self.len = str_len(self.s);
        return;
    }
    fun find(self, sub_string: String) -> int64 {
        let res = -1;
        let i = 0;
        let j = 0;
        let self_chars = to_chars(self.s);
        let sub_chars = to_chars(sub_string.s);
        while i < len(self_chars) {
            if self_chars[i] == sub_chars[j] {
                const size_sub_chars: int64 = len(sub_chars) as int64 - 1;
                if j == size_sub_chars {
                    res = i - j;
                    //break is not implemented yet...
                    break;
                }
                j = j + 1;
            } else {
                j = 0;
            }
            i = i + 1;
        }
        return res;
    }

    fun get(self, i: uint64) -> Char {
        return self.s[i];
    }
    fun set(self, i: uint64, c: Char) -> unit {
        self.s[i] = c;
        return;
    }

    fun to_str(self) -> Str {
        return self.s;
    }
    fun to_chars(self) -> [Char] {
        return to_chars(self.s);
    }
    fun to_upper(self) -> String {
        return new String(to_upper(self.s));
    }
    fun to_lower(self) -> String {
        return new String(to_lower(self.s));
    }
    fun trim(self) {
        return new String(trim(self.s));
    }
    fun split(self, sep: Str) -> [String] {
        let s: [Str] = split(self.s, sep);
        let i = 0;
        let res = new [String; len(s)];
        while i < len(s) {
            res[i] = new String(s[i]);
            i = i + 1;
        }
        return res;
    }
}

@public
struct RefChar {
    var value: Char;
    fun init(val: Char): RefChar {
        this.value = val;
    }
    fun to_str(this): Str {
        return this.value as Str;
    }
    fun from_str(s: Str): RefChar {
        return new RefChar(s.get(0));
    }
}
