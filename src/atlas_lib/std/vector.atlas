package std::vector;

public struct Vector<T> {
    private:
        data: [T];
    public:
        length: uint64;
        capacity: uint64;

    Vector([T] data) {
        self.length = std::list::len(data);
        self.capacity = self.length;
        self.data = data;
    }
    ~Vector() {
        delete self.data;
        self.data = 0;
        self.length = 0;
    }

    /// A function that doesn't have a "self" parameter is a static function
    /// static functions are called like this: "Vector::<T>::function_name()"
    fn with_capacity(capacity: uint64) -> Vector<T> {
        return new Vector::<T>(new [T; capacity]);
    }

    /// A function that has a "self" parameter is a method of the struct
    /// and is called like this: "vector_instance.function_name()"
    fn push(self, val: T) {
        if self.capacity <= self.length {
            let new_capacity = self.capacity * 2;

            let new_data = new [T; new_capacity];
            let i = 0;
            while i < self.length {
                new_data[i] = self.data[i];
                i = i + 1;
            }
            let data_to_delete = self.data;
            self.data = new_data;
            self.capacity = new_capacity;

            delete data_to_delete;
        }
        self.data[self.length] = val;
        self.length = self.length + 1;
    }
    fn pop(self) -> T {
        if self.length == 0 {
            std::panic("Cannot pop from an empty vector");
        }
        self.length = self.length - 1;
        return self.data[self.length];
    }
}